<html>
<!-- Head tag -->
<head>

    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	
	
		<link href="/favicon.ico" rel="icon">
	 
      <title>2018面试题整理(待完善) | story-android</title>
	<link rel="stylesheet" href="/css/font-awesome/css/font-awesome.css">
	<link rel="stylesheet" href="/css/style.css">
	<link rel="stylesheet" href="/css/highlight.css">
	
	

</head>
<body>
	<div id="site" class="site">
		<div id="sidebar" class="sidebar">
			<header id="header" class="site-header">
	<div class="site-branding">
		<h1 class="site-title"><a href="/" rel="home">SingleMan丶司</a></h1>
		<p class="site-description">I&#39;m very ugly but I very gentleness</p>
		<button class="secondary-toggle font-asesome-icon">Menu and widgets</button>
	</div>
</header>
<div id="secondary" class="secondary">
	<nav class="main-navigation">
                         <ul id="menu-demo-menu" class="nav-menu">
						 
							<li class="menu-item"><a href="/">首页</a></li>
						
							<li class="menu-item"><a href="/archives">归档</a></li>
						
							<li class="menu-item"><a href="/about">关于</a></li>
						
                         </ul>
    </nav>
	
		
<aside class="widget">
		<h3 class="widget-title">归档</h3>		
		<ul>
			<ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a><span class="archive-list-count">4</span></li></ul>
		</ul>
	</aside>


	
		
<aside class="widget">
		<h3 class="widget-title">最新文章</h3>		
		<ul>
			
          <li>
            <a href="/2018/03/29/面试题整理(2018上)/">2018面试题整理(待完善)</a>
          </li>
        
          <li>
            <a href="/2018/03/29/图片添加水印/">图片添加水印</a>
          </li>
        
          <li>
            <a href="/2018/03/19/笔记/">笔记及知识点</a>
          </li>
        
          <li>
            <a href="/2018/03/13/分享图片文字到朋友圈（适配7.0）/">分享多张图片到微信朋友圈</a>
          </li>
        
		</ul>
	</aside>


	
		
	
</div>
		</div>
		<div id="content" class="site-content">
			<main id="main" class="site-main" role="main">
				
<article class="hentry ">
		
		
			<header class="entry-header">
				<h2 class="entry-title"><a href="/2018/03/29/面试题整理(2018上)/" rel="bookmark">2018面试题整理(待完善)</a></h2>	
			</header>
		
		<!-- .entry-header -->
		<div class="entry-content">
			
				<p> ###java中==和equals和hashCode的区别？<br>==是运算符，用于比较两个变量是否相等。<br>equals，是Objec类的方法，用于比较两个对象是否相等，默认Object类的equals方法是比较两个对象的地址。<br>Haskcoed 是object的类的方法，返回一个int类型的整数，在集合中使用时提升查询速度。<br>==比较的都是地址值，equals在没有被重写的情况下也是用==号实现的。所以比较结果相同。</p>
<p>###int、char、long各占多少字节数？<br>整型   int  4字节<br>长整型 long 4字节<br>字符型 char 1字节<br>单精度 float 4字节<br>双精度 double 8字节<br>长双精度 long double 8字节</p>
<p>###Int Integer 区别?<br>1、Integer是int的包装类，int则是java的一种基本数据类型 。<br>2、Integer变量必须实例化后才能使用，而int变量不需要 。<br>3、Integer实际是对象的引用，当new一个Integer时，实际上是生成一个指针指向此对象；而int则是直接存储数据值 。<br>4、Integer的默认值是null，int的默认值是0。</p>
<p>###StringBuffer中很多方法可以带有synchronized关键字?<br>String线程安全，因为他是不可变类。StringBuilder是线程不安全的，而StringBuffer是线程安全的。<br>StringBuffer中很多方法可以带有synchronized关键字。<br>StrinBuilder -&gt; StringBuffer -&gt;String</p>
<p>###抽象类和接口区别?<br>第一点． 接口是抽象类的变体，接口中所有的方法都是抽象的。而抽象类是声明方法的存在而不去实现它的类。<br>第二点． 接口可以多继承，抽象类不行。<br>第三点． 接口定义方法，不能实现，而抽象类可以实现部分方法。<br>第四点． 接口中基本数据类型为static 而抽类象不是的。</p>
<p>#####接口的意义：<br>接口是一种规范，面向对象的一些公共行为。</p>
<p>###父类的静态方法能否被子类重写 ？<br>方法可以被继承，但是不可以被重写。</p>
<p>###进程和线程的区别？<br>（1）进程是资源的分配和调度的一个独立单元，而线程是CPU调度的基本单元。<br>（2）同一个进程中可以包括多个线程，并且线程共享整个进程的资源（寄存器、堆栈、上下文），一个进行至少包括一个线程。<br>（3）进程的创建调用fork或者vfork，而线程的创建调用pthread_create，进程结束后它拥有的所有线程都将销毁，而线程的结束不会影响同个进程中的其他线程的结束。<br>（4）线程是轻两级的进程，它的创建和销毁所需要的时间比进程小很多，所有操作系统中的执行功能都是创建线程去完成的。<br>（5）线程中执行时一般都要进行同步和互斥，因为他们共享同一进程的所有资源。<br>（6）线程有自己的私有属性TCB，线程id，寄存器、硬件上下文，而进程也有自己的私有属性进程控制块PCB，这些私有属性是不被共享的，用来标示一个进程或一个线程的标志。</p>
<p>###final、finally、finalize区别？</p>
<ul>
<li>Final用于修饰类、成员变量和成员方法。final修饰的类，不能被继承（String、StringBuilder、StringBuffer、Math，不可变类），其中所有的方法都不能被重写，所以不能同时用abstract和final修饰类（abstract修饰的类是抽象类，抽象类是用于被子类继承的，和final起相反的作用）；Final修饰的方法不能被重写，但是子类可以用父类中final修饰的方法；Final修饰的成员变量是不可变的，如果成员变量是基本数据类型，初始化之后成员变量的值不能被改变，如果成员变量是引用类型，那么它只能指向初始化时指向的那个对象，不能再指向别的对象，但是对象当中的内容是允许改变的。</li>
<li>Finally通常和try catch搭配使用，保证不管有没有发生异常，资源都能够被释放（释放连接、关闭IO流）。</li>
<li>Finalize是object类中的一个方法，子类可以重写finalize()方法实现对资源的回收。垃圾回收只负责回收内存，并不负责资源的回收，资源回收要由程序员完成，Java虚拟机在垃圾回收之前会先调用垃圾对象的finalize方法用于使对象释放资源（如关闭连接、关闭文件），之后才进行垃圾回收，这个方法一般不会显示的调用，在垃圾回收时垃圾回收器会主动调用。</li>
</ul>
<p>###java的静态方法不能被重写。 </p>
<ul>
<li>静态成员（方法或属性）是类的成员存放在栈中，类可以直接调用（是属于类的静态成员，当然对象也可以调用，只是说你可以使用而已）；实例成员是对象的成员，存放在堆中，只能被对象调用。 </li>
<li>重写的目的在于根据创造对象的所属类型不同而表现出多态。因为静态方法无需创建对象即可使用。没有对象，重写所需要的“对象所属类型” 这一要素不存在，因此无法被重写。</li>
</ul>
<h3 id="使用Java序列化把对象存储到文件中，再从文件中读出来"><a href="#使用Java序列化把对象存储到文件中，再从文件中读出来" class="headerlink" title="使用Java序列化把对象存储到文件中，再从文件中读出来"></a>使用Java序列化把对象存储到文件中，再从文件中读出来</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ObjectOutputStream os = <span class="keyword">new</span> ObjectOutputStream( newFileOutputStream(<span class="string">"C:/wxp.txt"</span>));  </div><div class="line">            os.writeObject(user);<span class="comment">// 将User对象写进文件  </span></div><div class="line">            os.writeObject(list);<span class="comment">// 将List列表写进文件  </span></div><div class="line">            os.close();  </div><div class="line"></div><div class="line">ObjectInputStream is = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream( <span class="string">"C:/wxp.txt"</span>));  </div><div class="line">            User temp = (User) is.readObject();<span class="comment">// 从流中读取User的数据  </span></div><div class="line">            System.out.println(temp.getId());  </div><div class="line">            System.out.println(temp.getName());  </div><div class="line">            List tempList = (List) is.readObject();<span class="comment">// 从流中读取List的数据  </span></div><div class="line">            <span class="keyword">for</span> (Iterator iterator = tempList.iterator(); iterator.hasNext();) &#123;  </div><div class="line">                System.out.print(iterator.next());  </div><div class="line">            &#125;  </div><div class="line">            is.close();</div></pre></td></tr></table></figure>
<p>###反射的理解？<br>在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法；生成动态代理。<br>1、包<br>@Target(ElementType.PACKAGE)<br><br>2、接口、类、枚举、注解<br>@Target(ElementType.TYPE)<br><br>3、注解<br>@Target(ElementType.ANNOTATION_TYPE)<br><br>4、构造函数<br>@Target(ElementType.CONSTRUCTOR)<br><br>5、局部变量<br>@Target(ElementType.LOCAL_VARIABLE)<br><br>6、方法<br>@Target(ElementType.METHOD)<br><br>7、方法的参数<br>@Target(ElementType.PARAMETER)</p>
<p>1、在源代码中保留<br>@Retention( RetentionPolicy.SOURCE)<br><br>2、在Class文件中保留<br>@Retention( RetentionPolicy.CLASS)<br><br>3、在运行时保留<br>@Retention( RetentionPolicy.RUNTIME) </p>
<p>@Inherited注解主要说明了一种继承性，意思是子类可以继承父类中的该注解（注意：只有当被贴上@Inherited标签的注解被用在类上的时候子类才能获得这个注解）。就像之前提到的，如果父母是农村户口，那么他们的孩子也默认就是农村户口了。</p>
<p>###String 为什么设计成不可变的？</p>
<ul>
<li>如果字符串可变的话，当两个引用指向指向同一个字符串时，对其中一个做修改就会影响另外一个；</li>
<li>Java中经常会用到字符串的哈希码（hashcode）。例如，在HashMap中，字符串的不可变能保证其hashcode永远保持一致，这样就可以避免一些不必要的麻烦。这也就意味着每次在使用一个字符串的hashcode的时候不用重新计算一次，这样更加高效。</li>
<li>不可变对象天生就是线程安全的。因为不可变对象不能被改变，所以他们可以自由地在多个线程之间共享。不需要任何同步处理。<br>总之，String被设计成不可变的主要目的是为了安全和高效。所以，使String是一个不可变类是一个很好的设计。</li>
</ul>
<p>###list与Set、Map区别及适用场景？</p>
<ul>
<li>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。 </li>
<li>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。</li>
<li>Map适合储存键值对的数据。</li>
<li><p>线程安全集合类与非线程安全集合类 。</p>
</li>
<li><p>LinkedList、ArrayList、HashSet是非线程安全的，Vector是线程安全的;</p>
</li>
<li>HashMap是非线程安全的，HashTable是线程安全的;</li>
<li>StringBuilder是非线程安全的，StringBuffer是线程安全的。</li>
</ul>
<p>###ArrayList与LinkedList的区别和适用场景</p>
<p>#####Arraylist：<br><strong>优点</strong>：ArrayList是实现了基于动态数组的数据结构,因为地址连续，一旦数据存储好了，查询操作效率会比较高（在内存里是连着放的）。<br><strong>缺点</strong>：因为地址连续， ArrayList要移动数据,所以插入和删除操作效率比较低。<br>LinkedList：<br><strong>优点</strong>：LinkedList基于链表的数据结构,地址是任意的，所以在开辟内存空间的时候不需要等一个连续的地址，对于新增和删除操作add和remove，LinedList比较占优势。LinkedList 适用于要头尾操作或插入指定位置的场景<br><strong>缺点</strong>：因为LinkedList要移动指针,所以查询操作性能比较低。<br>适用场景分析：<br> 当需要对数据进行对此访问的情况下选用ArrayList，当需要对数据进行多次增加删除修改时。</p>
<p> #####LinkedList：<br>ArrayList与Vector的区别和适用场景<br>.Vector是多线程安全的，线程安全就是说多线程访问同一代码，不会产生不确定的结果。而ArrayList不是，这个可以从源码中看出，Vector类中的方法很多有synchronized进行修饰，这样就导致了Vector在效率上无法与ArrayList相比；</p>
<p>###HashMap与TreeMap、HashTable的区别及适用场景<br>HashMap 非线程安全 。<br>HashMap：基于哈希表实现。使用HashMap要求添加的键类明确定义了hashCode()和equals()[可以重写hashCode()和equals()]，为了优化HashMap空间的使用，您可以调优初始容量和负载因子。<br>TreeMap：非线程安全基于红黑树实现。TreeMap没有调优选项，因为该树总处于平衡状态。<br>适用场景分析：<br>HashMap和HashTable:HashMap去掉了HashTable的contains方法，但是加上了containsValue()和containsKey()方法。HashTable同步的，而HashMap是非同步的，效率上比HashTable要高。HashMap允许空键值，而HashTable不允许。<br>HashMap：适用于Map中插入、删除和定位元素。<br>Treemap：适用于按自然顺序或自定义顺序遍历键(key)。</p>
<p>#<strong>Android </strong></p>
<p>###关于生命周期<br>点击Home键回到主界面(Activity不可见)–&gt;onPause()–&gt;onStop()<br>重新回到Activity时，调用了onRestart方法，onStart方法，onResume方法。因此，<br>当我们再次回到原Activity时–&gt;onRestart()–&gt;onStart()–&gt;onResume();<br>原Activity的基础上开启新的Activity，原Activity生命周期执行方法顺序为–&gt;onPause()–&gt;onStop();<br>如果新的Activity使用了透明主题，那么当前Activity不会回调onStop方法.</p>
<p>###Activity状态保存于恢复<br>onSaveInstanceState()<br>onRestoreInstanceState()</p>
<p>###下面是本地广播的用法以及和全局广播的区别：</p>
<ul>
<li>发送的广播只会在自己App内传播，不会泄露给其他App，确保隐私数据不会泄露。</li>
<li>其他App也无法向你的App发送该广播，不用担心其他App会来搞破坏。</li>
<li>比系统全局广播更加高效。<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">LocalBroadcastManager lbm = LocalBroadcastManager.getInstance(<span class="keyword">this</span>);</div></pre></td></tr></table></figure>
</li>
</ul>
<p>###请介绍一下ContentProvider是如何实现数据共享的。</p>
<p>Android提供了ContentProvider，一个程序可以通过实现一个ContentProvider的抽象接口将自己的数据完全暴露出去，而且ContentProvicer是以类似数据库中表的方式将数据暴露。也就是说ContentProvider就像一个“数据库”。那么外界获取其提供的数据，也就应该与从数据库中获取数据的操作基本一样，只不过是采用URI来表示外界需要访问的“数据库”。外部访问通过ContentResolver去访问并操作这些被暴露的数据。</p>
<p>###Application 和 Activity 的 Context 对象的区别</p>
<p>###回调的原理<br>举例：老板分派给员工做事，员工做完事情后需要给老板回复，老板对其做出反应。</p>
<p>###序列化Serializable和Parcelable</p>
<p>@Override<br>    public int describeContents() {<br>        return 0;<br>    }  </p>
<pre><code>@Override  
public void writeToParcel(Parcel dest, int arg1) {  
    dest.writeString(this.stuno);  
    dest.writeString(this.name);  
}  
public static final Parcelable.Creator&lt;Student&gt; CREATOR=new Creator&lt;Student&gt;(){  
    @Override  
    public Student createFromParcel(Parcel source) {  
        Student stu=new Student();  
        stu.setStuno(source.readString());  
        stu.setName(source.readString());  
        return stu;  
    } 
    @Override  
    public Student[] newArray(int arg0) {  
        return new Student[arg0];  
    } 
</code></pre><p>}; </p>
<p>###自定义view ？<br>onMeasure 测量以及计算view的宽高<br>OnDraw  使用Canvas和Paint绘制view的形状,样式。<br>OnLayout 如果viewgroup 的话可以设置子view的位置。对viewgroup内部子view进行排版布局。<br>onMeasure()会在初始化之后调用一到多次来测量控件或其中的子控件的宽高；<br>onLayout()会在onMeasure()方法之后被调用一次，将控件或其子控件进行布局；<br>onDraw()会在onLayout()方法之后调用一次，也会在用户手指触摸屏幕时被调用多次，来绘制控件。</p>
<p>###Requestlayout</p>
<ul>
<li>requeLayout() : 控件会重新执行 onMesure() onLayout() ,比如 ScrollView中有LinearLaout ，LinearLayout里面有纵向排列的ImageView和TextView,那么假如ImageView的长宽发生了变化，而要立即在手机上显示这个变化的话，就可调用 imageView.requestLayout();这样的话ScrollView 会重新执行onMesure()这个方法会确定控件的大小然后在确定出自己的宽高，最后在执行onLayout()，这个方法是对所有的子控件进行定位的。</li>
<li>invalidate() :是自定义View 的时候，重新执行onDraw()方法。</li>
<li>layout()：对控件进行重新定位执行onLayout()这个方法，比如要做一个可回弹的ScrollView，思路就是随着手势的滑动子控件滑动，那么我们可以将ScrollView的子控件调用layout（l,t,r,b）这个方法就行了。</li>
</ul>
<p>###invalidate和postInvalidate的区别及使用<br>invalidate()可以在主线程（UI线程）中调用，而不能在子线程中调用，若在子线程中进行刷新view的操作需要配合handler来使用。而postInvalidate()可以在子线程中直接调用。postInvalidate()底层也是通过handler来调用View的Invalidate()来刷新UI的</p>
<p>###GC机制</p>
<p>#####gc是java的垃圾回收机制：<br><strong>引用计数法</strong>（Reference Counting Collector）:使用计数器来区分存活对象和不再使用的对象。一般来说，堆中的每个对象对应一个引用计数器。当每一次创建一个对象并赋给一个变量时，引用计数器置为1。当对象被赋给任意变量时，引用计数器每次加1当对象出了作用域后(该对象丢弃不再使用)，引用计数器减1，一旦引用计数器为0，对象就满足了垃圾收集的条件。<br><strong>标记算法</strong>（Tracing Collector):使用了根集的概念，基于tracing算法的垃圾收集器从根集开始扫描，识别出哪些对象可达，哪些对象不可达，并用某种方式标记可达对象。<br><strong>整理算法</strong>（Compacting Collecotr）：该算法会将所有的对象移到堆的一端。能解决堆碎片的问题。<br><strong>复制算法</strong>：将内存分为两个区域（from space 和 to space）。所有的对象都分配到from space。清理时先将所有标为活动对象copy到to space，然后清除from space空间。然后互换from space和to apce的身份，每次清理都重复上述过程。</p>
<p>###什么是ANR,如何避免它。<br>应用程序无响应（Application Not Responding）对话框，用户可以选择让程序停止或者继续运行。不同的组件发生ANR的时间不一样，主线程是5s（Activity，Service），BroadCastReceiver是10秒。</p>
<p>######如何避免：<br>将所有的耗时操作，比如访问网络，Socket通信，查询，复杂逻辑运算等都放到子线程中去执行，让后通过handler.sendMessage,runonUIThread,AsyncTask等方式更新UI，确保用户操作界面的流畅度。如果耗时操作需要用户等待，可以在界面上显示进度条。</p>
<p>###自定义View如何考虑机型适配？</p>
<ul>
<li>合理使用warp_content，match_parent.</li>
<li>尽可能的是使用RelativeLayout</li>
<li>针对不同的机型，使用不同的布局文件放在对应的目录下，android会自动匹配。</li>
<li>尽量使用点9图片。</li>
<li>使用与密度无关的像素单位dp，sp</li>
<li>引入android的百分比布局。</li>
<li>切图的时候切大分辨率的图，应用到布局当中。在小分辨率的手机上也会有很好的显示效果。<br>###自定义view的优化<br>降低刷新频率，减少不必要的调用invalidate()方法；<br>初始化时创建对象；不要在onDraw方法内创建绘制对象，一般都在构造函数里面初始化对象；<br>状态的存储与恢复：如果内存不足，而恰好我们的Activity置于后台，不幸被重启，或者用户旋转屏幕造成Activity重启，我们的View应该也能尽可能的去保存自己的属性。<br>使用硬件加速。</li>
</ul>
<p>###对AIDL的理解<br>AIDL:android interface definition language的缩写。<br>AIDL是用来实现进程间通信的，可以帮我们实现发布以及调用远程服务。<br>使用：<br>1）服务端：创建一个Service用来监听客户端的连接请求，然后创建一个AIDL文件，将服务端暴露给客户端的接口在这个文件中声明，最后在Service中实现这个AIDL接口。<br>2）客户端：首先绑定服务端的Service，绑定成功后将服务端返回的Binder对象转成AIDL接口所属的类型，接着就可以调用AIDL中的方法</p>
<p>###如何保证一个后台服务不被杀死？<br>Android中通过Service实现后台任务。<br><strong>方法一</strong>：<br>通过将Service绑定到Notification，成为一个前提服务，可以提高存活率在Service中创建一个Notification，再调用Service.startForeground(int id,Notification notification)方法运行在前台即可。这个方式使用360等如阿健管家可以杀死。<br><strong>方法二</strong>：<br>通过定时警报来不断启动Service，这样就算Service被杀死，也能再启动。同时也可以监听网络切换，开锁屏等广播启动Service。<br>参考：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Intent intent = <span class="keyword">new</span> Intent（mContext，MyService.class）；</div><div class="line">PendingIntent sender = PendingIntent.getService(mContext,<span class="number">0</span>,intent,<span class="number">0</span>);</div><div class="line">AlarmManager alarm = (AlarmManager)getSystemService(ALARM_SERVICE);</div><div class="line">alarm.setRepeating(AlarmManager.RTC_WAKEUP,System.currentTimeMillis(),<span class="number">5</span>*<span class="number">10000</span>,sender);</div></pre></td></tr></table></figure></p>
<p><em>这种方式不断启动的逻辑处理起来很麻烦。</em></p>
<p><strong>方法三</strong>：<br>通过jni调用c，在c语音中启动一个进程fork（）。 可以保证360等手机管家不会清理。但是带来了jni交互，稍微有点麻烦。</p>
<p>###Handler 的原理？<br>Handler:用来发送消息，处理消息<br>Message:消息实体对象，handler通过sendMsg将实体放到消息队列里面<br>MessageQueue：存放消息的队列<br>Looper：消息轮询器，轮询消息队列的消息然后取出，交给handler处理。</p>
<ul>
<li>主线程是 有且仅有一个Looper对象， Looper对象里又有一个MessageQueue。</li>
<li>Looper 负责不停的loop，并调用Handler的handleMessage处理Message。</li>
<li>Handler 负责投递message， 以及提供处理消息的方法handleMessage。</li>
<li>任何非主线程， 想要给 主线程发message， 必须通过handler（该handler内部包含了主线程的Looper引用）<br>#####扩展下：<br>不只是涉及主线程， 任意 子线程之间要传递异步消息的话，也可以用handler， 该handler中引用的looper对象是属于那个线程的， 就会把消息投递给该线程， 并在该线程里执行 handleMessage方法。 </li>
</ul>
<p>###View 事件分发机制？</p>
<ul>
<li>如果ViewGroup找到了能够处理该事件的View，则直接交给子View处理，自己的onTouchEvent不会被触发；</li>
<li>可以通过复写onInterceptTouchEvent(ev)方法，拦截子View的事件（即return true），把事件交给自己处理，则会执行自己对应的onTouchEvent方法</li>
<li>子View可以通过调用getParent().requestDisallowInterceptTouchEvent(true);  阻止ViewGroup对其MOVE或者UP事件进行拦截；</li>
</ul>
<p>###OnThouch和OnThouchEvent<br>onTouchListener的onTouch方法优先级比onTouchEvent高，会先触发。</p>
<p>假如onTouch方法返回false会接着触发onTouchEvent，反之onTouchEvent方法不会被调用。</p>
<p>内置诸如click事件的实现等等都基于onTouchEvent，假如onTouch返回true，这些事件将不会被触发。</p>
<p><strong>顺序为: </strong><br>onTouch—–&gt;onTouchEvent—&gt;onclick </p>
<p>###为什么不能在子线程更新UI？<br>Android的UI访问是没有加锁的，这样在多个线程访问UI是不安全的。所以Android中规定只能在UI线程中访问UI。</p>
<p>###ANR 产生原因？<br> a.主线程对输入事件5秒内没有处理完毕<br> b.主线程在执行BroadcastReceiver的onReceive()函数时10秒内没有处理完毕<br> c.主线程在Service的各个生命周期函数时20秒内没有处理完毕。</p>
<p>1.避免在主线程执行耗时操作，所有耗时操作应新开一个子线程完成，然后再在主线程更新UI。<br>2.BroadcastReceiver要执行耗时操作时应启动一个service，将耗时操作交给service来完成。</p>
<p>###OOM?<br>OOM（out of memory）即内存泄露。一个程序中，已经不需要使用某个对象，但是因为仍然有引用指向它垃圾回收器就无法回收它，当该对象占用的内存无法被回收时，就容易造成内存泄露。</p>
<p>######原因：</p>
<ul>
<li>资源对象没关闭造成的内存泄露，try catch finally中将资源回收放到finally语句可以有效避免OOM。资源性对象比如 Cursor。</li>
<li>调用registerReceiver后未调用unregisterReceiver()。</li>
<li>未关闭InputStream/OutputStream。</li>
<li>Bitmap使用后未调用recycle()。<br>######避免：</li>
<li>使用缓存技术，比如LruCache、DiskLruCache、对象重复并且频繁调用可以考虑对象池</li>
<li>对于引用生命周期不一样的对象，可以用软引用或弱引用SoftReferner  WeakReference</li>
<li>对于资源对象 使用finally 强制关闭</li>
<li>内存压力过大就要统一的管理内存</li>
<li>对于java中不再使用的资源需要尽快的释放，即设置成null，不要老是指望垃圾回收器为你工作。如果不设置成null，那么资源回收会受到一定的影响。</li>
<li>尽量少用static方法和static成员。因为static的方法或成员被外部使用的话，而外部的牵引对象没有对其进行释放的话那么整个static的类都不会被释放，也就造成内存泄漏。</li>
<li>对于不再使用的bitmap应该手动调用recycle方法，并且设置成null。图片还要尽量使用软引用方式，这样可以加快垃圾回收。</li>
</ul>
<p>##算法题</p>
<p>###判断101-200之间有多少个素数，并输出所有素数。<br>1.程序分析：判断素数的方法：用一个数分别去除2到sqrt(这个数)，如果能被整除，则表明此数不是素数，反之是素数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo02</span></span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=<span class="number">200</span>;i++)&#123;</div><div class="line">            <span class="keyword">boolean</span> flag=<span class="keyword">true</span>;</div><div class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">2</span>;j&lt;i;j++)&#123;</div><div class="line">                <span class="keyword">if</span>(i%j==<span class="number">0</span>)&#123;</div><div class="line">                    flag=<span class="keyword">false</span>;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span>(flag==<span class="keyword">true</span>)&#123;</div><div class="line">                System.out.print(<span class="string">" "</span>+i);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>###模块化浅谈</p>
<p>####1. Android 模块化开发介绍；<br>模块化开发思路就是：单独开发每个模块，用集成的方式把他们组合起来，就能拼出一个app。app可以理解成很多功能模块的组合，而且有些功能模块是通用的，必备的，像自动更新，反馈，推送，都可以提炼成模块，和搭积木很像，由一个壳包含很多个模块。</p>
<p>####2.Android 模块化开发的好处；<br>模块升级会单独升级，升级的时候往往不只是增加资源，有时候会去删资源，这样做和其它的模块的资源不掺乎，我用umeng的自动更新sdk时就需要我连着资源一块进来，加进来容易以后不想用umeng的了再挑出去就很费事了。再假如push开始用的百度的后来换成极光的，对app的组合者其实是不关心的，对他影响很小。解耦很好。如果是主力带实习生这种开发的话，核心代码就不用和他们分享，让他们去做独立的功能，做好直接调用就行。以后整理代码，重构什么的都只重构这个模块的代码，他们不会不小心改了核心代码。</p>
<p>###设计模式<br><strong>Abstract Factory：这个是＂抽象工厂模式＂</strong>，用于提供一个创建一系列相关或相互依赖对象的接口，而无需指定他们具体的类．<br><strong>Adapter：适配器模式</strong>，根据字面意思很好理解．将每一个类的接口转换成客户希望的另外一个接口．Ａｄａｐｔｅｒ使得原本接口不兼容而不能一起工作的那些类可以一起工作．<br><strong>Bridge：桥梁模式</strong>，将抽象部分与它的实现部分分离，使他们都可以独立地变化．<br><strong>Builder：建筑者模式</strong>，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示．<br><strong>Chain of Responsibility：职责链模式</strong>，为解除请求的发送者和接收者之间耦合，而使用多个对象都有机会处理这个请求．将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它．<br><strong>Command：命令模式</strong>，将一个请求封装成一个对象，从而使你可用不同的请求对客户进行参数化;对请求排队或记录请求日志，以及支持可取消操作．<br><strong>Composite：组合模式</strong>，将对象组合成树形结构以表示＂部分－整体＂的层次结构．Ｃｏｍｐｏｓｉｔｅ使得客户对单个对象和复合对象的使用具有一致性．<br><strong>Decorator：装饰模式</strong>，动态的给一个对象添加一些额外的职责．就扩展性而言，Decorator模式比生成子类方式更为灵活．<br><strong>Facade：外观模式</strong>，为系统中的一组接口提供一个一致的界面，ｆａｃａｄｅ模式定义了一个高层接口，这个接口使得这一子系统更加容易使用．<br><strong>Factory Method：工厂方法模式</strong>，定义一个用于创建对象接口，让子类决定将哪一个类实例化．Factory Method使一个类的实例化延迟到其子类．<br><strong>Flyweight：享元模式</strong>，运用共享技术有效地支持大量细粒度的对象．<br><strong>Interpreter：解释器模式</strong>，给定一个语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子．解释器模式需要解决的是，如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。比如正则表达式．<br><strong>Iterator：迭代器模式</strong>，提供一种方法顺序访问一个聚合对象中各个元素，而又不需要暴露该对象的内部表示．<br><strong>Mediator：中介模式</strong>，用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。<br><strong>Memento：备忘录模式</strong>，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到保存的状态。<br><strong>Observer：观察者模式</strong>，定义对象间的一种一对多的依赖关系,以便当一个对象的状态发生改变时,所有依赖于它的对象都得到通知并自动刷新。<br><strong>Prototype：原型模式</strong>，用原型实例指定创建对象的种类，并且通过拷贝这个原型来创建新的对象。<br><strong>Proxy：代理模式</strong>，为其他对象提供一个代理以控制对这个对象的访问。<br><strong>Singleton：单例模式</strong>，保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br><strong>State：状态模式</strong>，允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它所属的类．<br><strong>Strategy：策略模式</strong>，：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。本模式使得算法的变化可独立于使用它的客户。<br><strong>Template Method：模板方法模式</strong>，定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。<br><strong>Visitor：访问者模式</strong>，表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
<h3 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h3><p>Model在MVC架构中起的作用非常重要，它应该是业务逻辑真正的实现层。所以Model的实际上是Business Model（业务模型）。而Controller仅仅起一个“桥梁”作用，它负责把View的请求转发给Model，再负责把Model处理结束的消息通知View。Controller是用来解耦View和Model的，具体一点说，就是为了让UI与逻辑分离（界面与代码分离）。</p>
<p>###FastJson原理： </p>
<p>-对象 to JSON ：利用反射找到对象类的所有Get方法，然后把”get”去掉，小写化，作为JSON的每个key值，如 getA  对应的key值为 a，而与真实的类成员名无关。</p>
<p>-JSON to  pojo ：先同样通过反射找到对象类所有的Set方法，然后使用无参数构造函数（所以一定要有无参数的构造函数）新建一个类对象，从JSON字符串中取出一个key 如 a，先大写化为A，那么从所有Set方法中找到 SetA()，然后进行赋值。 如果找不到 setA （seta也不行），那么该值被忽略，也不报错。</p>
<p>###Picasso与Glide<br>Picasso 是下载图片然后缓存完整的大小到本地，比如说图片的大小是1080p的，之后如果我需要同一张图片，就会返回这张 full size 的，如果我需要resize，也是对这种 full size 的做 resize。</p>
<p>Glide 则是完全不一样的做法。Glide 是会先下载图片，然后改变图片的大小，以适应 imageView 的要求，然后缓存到本地。 所以如果你是下载同一张图片，但是设定两个不一样大小的 imageView, 那么Glide 实际上是会缓存两份。</p>
<p>因为Picasso 是直接把图加载到内存中，而 Glide 则需要改变图片大小再加载到内存中去。这个应该是会耗费一定的时间。<br>当加载图片从内存中的时候，Glide 则比 Picasso 要快。其原理还是因为缓存机制的区别。因为Picasso 从缓存中拿到的图片，还要先去 resize 后，然后设定给 imageView，但是 Glide 则不需要这样。</p>
<p>###集成 Tinker 及初始化。<br>构建基准包及生成补丁文件。<br>Tinker 平台使用及发布补丁。</p>
<p>###ORMLite<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@DatabaseTable</span>(tableName = <span class="string">"author"</span>)</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Author</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</div><div class="line">        <span class="meta">@DatabaseField</span>(generatedId = <span class="keyword">true</span>)</div><div class="line">        <span class="keyword">public</span> <span class="keyword">int</span> id;</div><div class="line">        <span class="meta">@DatabaseField</span></div><div class="line">        <span class="keyword">private</span> String name;</div><div class="line">        <span class="meta">@DatabaseField</span></div><div class="line">        <span class="keyword">private</span> String pwd;</div><div class="line">        <span class="comment">// 一个作者可以对应多个笔记（确立关系的关键）</span></div><div class="line">        <span class="meta">@ForeignCollectionField</span>(eager = <span class="keyword">true</span>)</div><div class="line">        <span class="keyword">public</span> ForeignCollection&lt;Note&gt; notes;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">@DatabaseTable</span>(tableName = <span class="string">"note"</span>)</div><div class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Note</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</div><div class="line">        <span class="meta">@DatabaseField</span>(generatedId = <span class="keyword">true</span>)</div><div class="line">        <span class="keyword">private</span> <span class="keyword">int</span> id;</div><div class="line">        <span class="comment">/*@DatabaseField(id = true)</span></div><div class="line">        private Integer noteId;*/</div><div class="line">        <span class="comment">// 外部对象字段（确立关系的关键）</span></div><div class="line">        <span class="meta">@DatabaseField</span>(foreign = <span class="keyword">true</span>,foreignAutoRefresh = <span class="keyword">true</span>)</div><div class="line">        <span class="keyword">public</span> Author author</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="End"><a href="#End" class="headerlink" title="End"></a>End</h3>
			
		</div><!-- .entry-content -->
		
			<div class="entry-comments">
				 
  
   
      <!-- ��˵���ۿ� start -->
	<div class="ds-thread" data-thread-key="2018/03/29/面试题整理(2018上)/" data-title="2018面试题整理(待完善)" data-url="http://siyujie.github.io/2018/03/29/面试题整理(2018上)/"></div>
<!-- ��˵���ۿ� end -->
<!-- ��˵����JS���� start (һ����ҳֻ������һ��) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"troyyang"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.unstable.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
<!-- ��˵����JS���� end -->
 
			</div>
		
		<footer class="entry-footer">
			<span class="posted-on font-asesome-icon">
	<a href="" rel="bookmark">
	<time class="updated" datetime="2018-03-29T05:09:15.281Z">2018-03-29</time>
	</a>
</span>

		

    <span class="eye font-asesome-icon" >
         <span id="/2018/03/29/面试题整理(2018上)/" class="leancloud_visitors" data-flag-title="2018面试题整理(待完善)">
        
        </span>
    </span>

		</footer><!-- .entry-footer -->
</article>
<div class="misc">
    <a href="#main"><span class="top font-asesome-icon">Top</span></a>
</div>
			</main>
		</div>
		<footer id="colophon" class="site-footer">
			<div class="site-info">
				<span>powered by <a href="https://hexo.io/">Hexo</a>&nbsp;&nbsp; theme by <a href="https://github.com/Troy-Yang/hexo-theme-twentyfifteen-wordpress">Troy</a> &nbsp; inspired by <a href="https://wordpress.org/themes/">wordpress</a></span>
			</div><!-- .site-info -->
		</footer>
	</div>
	<div id="infinite-footer">
            <div class="container">
                <div class="blog-info">
                    <a id="infinity-blog-title" href="#" rel="home" title="Scroll back to top">
                         Happy Coding, Happy Life!
                    </a>
                </div>
                <div class="blog-credits">
					<span>蜀ICP备15004900号-1</span>
                </div>
            </div>
        </div><!-- #infinite-footer -->
    <!-- After footer scripts -->
    <script src="/js/jquery-3.1.1.min.js"></script>
<script src="/js/main.js"></script>

    <!--referring from https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html -->
    <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
    <script>
        AV.initialize("null", "null");
    </script>
    <script>
        function showTime(Counter) {
            var query = new AV.Query(Counter);
            $(".leancloud_visitors").each(function () {
                var url = $(this).attr("id").trim();
                query.equalTo("url", url);
                query.find({
                    success: function (results) {
                        if (results.length == 0) {
                            var content = $(document.getElementById(url)).text() + ': 0';
                            $(document.getElementById(url)).text(content);
                            return;
                        }
                        for (var i = 0; i < results.length; i++) {
                            var object = results[i];
                            var content = $(document.getElementById(url)).text() + ': ' + object.get('time');
                            $(document.getElementById(url)).text(content);
                        }
                    },
                    error: function (object, error) {
                        console.log("Error: " + error.code + " " + error.message);
                    }
                });
            });
        }
        function addCount(Counter) {
            var Counter = AV.Object.extend("Counter");
            url = $(".leancloud_visitors").attr('id').trim();
            title = $(".leancloud_visitors").attr('data-flag-title').trim();
            var query = new AV.Query(Counter);
            query.equalTo("url", url);
            query.find({
                success: function (results) {
                    if (results.length > 0) {
                        var counter = results[0];
                        counter.fetchWhenSave(true);
                        counter.increment("time");
                        counter.save(null, {
                            success: function (counter) {
                                var content = $(document.getElementById(url)).text() + ': ' + counter.get('time');
                                // remove ': '
                                $(document.getElementById(url)).text(counter.get('time'));
                            },
                            error: function (counter, error) {
                                console.log('Failed to save Visitor num, with error message: ' + error.message);
                            }
                        });
                    } else {
                        var newcounter = new Counter();
                        newcounter.set("title", title);
                        newcounter.set("url", url);
                        newcounter.set("time", 1);
                        newcounter.save(null, {
                            success: function (newcounter) {
                                console.log("newcounter.get('time')=" + newcounter.get('time'));
                                var content = $(document.getElementById(url)).text() + ': ' + newcounter.get('time');
                                // remove ': '
                                $(document.getElementById(url)).text(newcounter.get('time'));
                            },
                            error: function (newcounter, error) {
                                console.log('Failed to create');
                            }
                        });
                    }
                },
                error: function (error) {
                    console.log('Error:' + error.code + " " + error.message);
                }
            });
        }
        $(function () {
            var Counter = AV.Object.extend("Counter");
            if ($('.leancloud_visitors').length == 1) {
                addCount(Counter);
            } else if ($('.post-title-link').length > 1) {
                showTime(Counter);
            }
        });
    </script>
    
</body>
</html>